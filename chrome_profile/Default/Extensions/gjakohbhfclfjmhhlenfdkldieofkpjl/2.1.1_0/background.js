import{b as r,c as P,s as l,f as m,w as y,a as b,e as C,d as v,g as _,t as E,i as A}from"./chunks/_virtual_wxt-plugins-DHgd7gkO.js";import{i as L}from"./chunks/tiny-invariant-CopsF_GD.js";function T(o){return o==null||typeof o=="function"?{main:o}:o}const k=(o,e)=>Object.assign(o,e),x=o=>o!=null&&o!=="",F=["localhost","https://apid.iproyal.com","https://resi-api.iproyal.com"],u={cancel:!0},B=async o=>{const e=[`http://${o}`,`https://${o}`];await r.browsingData.remove({origins:e},{cookies:!0,cacheStorage:!0,serviceWorkers:!0})},S=o=>({mode:"fixed_servers",rules:{singleProxy:{scheme:o.type,host:o.host,port:o.port},bypassList:[...F,...o.bypassList]}});class I{#o;constructor(e){this.#o=e}#e=async(e,t)=>{if(!t){console.error("[proxyAuthHandler] callback is not defined");return}const{challenger:n,isProxy:i}=e;if(!i)return t(u);const s=await this.#o();if(!s){console.info("[proxyAuthHandler] No proxy config"),t(u);return}if(n.port===s.port&&n.host===s.host&&x(s.username)&&x(s.password)){console.info("Handling proxy auth request",e);const d={authCredentials:{username:s.username,password:s.password}};t(d);return}t(u)};setProxy=async()=>{const e=await this.#o();L(e);const t=S(e);await r.proxy.settings.set({value:t,scope:"regular"}),await B(e.host)};clearProxy=async()=>{await r.proxy.settings.clear({scope:"regular"})};init=()=>{r.webRequest.onAuthRequired.addListener(this.#e,{urls:["<all_urls>"]},["asyncBlocking"])};proxyError={addListener:e=>{r.proxy.onProxyError.addListener(e)},removeListener:e=>{r.proxy.onProxyError.removeListener(e)}}}const f=async()=>{const{levelOfControl:o}=await r.proxy.settings.get({});switch(o){case"not_controllable":case"controlled_by_other_extensions":return{canControlProxy:!1,cause:o};case"controllable_by_this_extension":case"controlled_by_this_extension":return{canControlProxy:!0};default:return{canControlProxy:!0}}},g=o=>o instanceof Error?o.message:JSON.stringify(o),V=I,H=async()=>{const o=await l.getValue();return o?m(o):null};class N{proxyApi=new V(H);#o={status:"disconnected",error:null};#e=e=>{k(this.#o,e),P.setValue(this.#o),this.#r()};#r(){const{status:e}=this.#o;if(e==="disconnected"){r.action.setBadgeText({text:""});return}let t="#27D9E5",n="#001A52",i="on";e==="error"&&(t="#FF0000",n="#FFFFFF",i="err"),r.action.setBadgeBackgroundColor({color:t}),r.action.setBadgeTextColor({color:n}),r.action.setBadgeText({text:i})}#t=e=>{console.debug("Proxy error",e)};async connect(){const{canControlProxy:e,cause:t}=await f();e||this.#e({status:"error",error:`Can't set proxy due to: ${t}`});try{await this.proxyApi.setProxy(),this.#e({status:"connected",error:null})}catch(n){this.#e({status:"error",error:`Failed to turn on proxy with config because of error, ${g(n)}`});return}console.info("Proxy turned on"),this.proxyApi.proxyError.addListener(this.#t)}async disconnect(){const{canControlProxy:e,cause:t}=await f();if(this.#e({status:"disconnected",error:null}),!e){this.proxyApi.proxyError.removeListener(this.#t),console.info(`Proxy cant be controlled due to: ${t}`),console.info("Set state to turned off");return}try{await this.proxyApi.clearProxy()}catch(n){console.error(`Failed to turn off proxy due to error: ${g(n)}`)}this.proxyApi.proxyError.removeListener(this.#t),console.info("Proxy turned off")}init=()=>{this.proxyApi.init?.()}}const c=new N,h=async()=>{await l.getValue()&&(console.info("Initializing proxy"),await c.connect(),p({proxyConnected:!0}))},R=async o=>{o?await c.connect():await c.disconnect(),p({proxyConnected:!!o})},p=async(o={})=>{const[e,t]=await Promise.all([o.proxyConnected??l.getValue().then(d=>!!d),o.protectionEnabled??y.getValue()]),n=e&&t,i=r.privacy.network.webRTCIPHandlingPolicy;await i.set({value:n?"disable_non_proxied_udp":"default"}),(await i.get({})).levelOfControl!=="controlled_by_this_extension"&&n&&y.setValue(!1)},$=T({type:"module",main:()=>{c.init(),y.watch(e=>{p({protectionEnabled:e})}),l.watch(e=>{R(e)}),r.runtime.onInstalled.addListener(()=>{h()}),r.runtime.onStartup.addListener(()=>{h()});const o=async e=>{if(e.type==="login"){const{options:t}=e;await b.setValue(t.accessToken),r.notifications.create({type:"basic",title:v(),iconUrl:"icon/48.png",message:C()}),_(t.userId).then(()=>E("login",{}))}};r.runtime.onMessage.addListener(e=>{const t=e;typeof t=="object"&&o(t)})}});function a(o,...e){}const q={debug:(...o)=>a(console.debug,...o),log:(...o)=>a(console.log,...o),warn:(...o)=>a(console.warn,...o),error:(...o)=>a(console.error,...o)};let w;try{A(),w=$.main(),w instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(o){throw q.error("The background crashed on startup!"),o}
